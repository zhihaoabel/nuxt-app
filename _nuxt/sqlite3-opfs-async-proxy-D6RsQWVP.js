!function(){"use strict";var e;const t=(e,...t)=>postMessage({type:e,payload:t}),n=function(){var e;const n=function(...e){throw new Error(e.join(" "))};globalThis.window===globalThis?n("This code cannot run from the main thread.","Load it as a Worker from a separate Worker."):(null==(e=null==navigator?void 0:navigator.storage)?void 0:e.getDirectory)||n("This API requires navigator.storage.getDirectory.");const s=Object.create(null);s.verbose=1;const a={0:console.error.bind(console),1:console.warn.bind(console),2:console.log.bind(console)},i=(e,...t)=>{s.verbose>e&&a[e]("OPFS asyncer:",...t)},o=(...e)=>i(2,...e),r=(...e)=>i(1,...e),c=(...e)=>i(0,...e),l=Object.create(null),d=new Set,f=function(e,t){const n=new URL(e,"file://irrelevant").pathname;return t?n.split("/").filter((e=>!!e)):n},y=async function(e,t=!1){const n=f(e,!0),a=n.pop();let i=s.rootDir;for(const s of n)s&&(i=await i.getDirectoryHandle(s,{create:!!t}));return[i,a]},u=async e=>{if(e.syncHandle){o("Closing sync handle for",e.filenameAbs);const t=e.syncHandle;return delete e.syncHandle,delete e.xLock,d.delete(e.fid),t.close()}},E=async e=>{try{await u(e)}catch(t){r("closeSyncHandleNoThrow() ignoring:",t,e)}},b=async()=>{if(d.size)for(const e of d){const t=l[e];await E(t),o("Auto-unlocked",e,t.filenameAbs)}},g=async e=>{if(e.releaseImplicitLocks&&d.has(e.fid))return E(e)};class O extends Error{constructor(e,...t){super([...t,": "+e.name+":",e.message].join(" "),{cause:e}),this.name="GetSyncHandleError"}}O.convertRc=(e,t)=>{if(e instanceof O){if("NoModificationAllowedError"===e.cause.name||"DOMException"===e.cause.name&&0===e.cause.message.indexOf("Access Handles cannot"))return s.sq3Codes.SQLITE_BUSY;if("NotFoundError"===e.cause.name)return s.sq3Codes.SQLITE_CANTOPEN}else if("NotFoundError"===(null==e?void 0:e.name))return s.sq3Codes.SQLITE_CANTOPEN;return t};const h=async(e,t)=>{if(!e.syncHandle){const a=performance.now();o("Acquiring sync handle for",e.filenameAbs);const i=6,c=2*s.asyncIdleWaitTime;let l=1,f=c;for(;;f=c*++l)try{e.syncHandle=await e.fileHandle.createSyncAccessHandle();break}catch(n){if(l===i)throw new O(n,"Error getting sync handle for",t+"().",i,"attempts failed.",e.filenameAbs);r("Error getting sync handle for",t+"(). Waiting",f,"ms and trying again.",e.filenameAbs,n),Atomics.wait(s.sabOPView,s.opIds.retry,0,f)}o("Got",t+"() sync handle for",e.filenameAbs,"in",performance.now()-a,"ms"),e.xLock||(d.add(e.fid),o("Acquired implicit lock for",t+"()",e.fid,e.filenameAbs))}return e.syncHandle},w=(e,t)=>{o(e+"() => notify(",t,")"),Atomics.store(s.sabOPView,s.opIds.rc,t),Atomics.notify(s.sabOPView,s.opIds.rc)},p=function(e,t){t.readOnly&&n(e+"(): File is read-only: "+t.filenameAbs)};let I=!1;const m={"opfs-async-shutdown":async()=>{I=!0,w("opfs-async-shutdown",0)},mkdir:async e=>{let t=0;try{await y(e+"/filepart",!0)}catch(n){s.s11n.storeException(2,n),t=s.sq3Codes.SQLITE_IOERR}w("mkdir",t)},xAccess:async e=>{let t=0;try{const[t,n]=await y(e);await t.getFileHandle(n)}catch(n){s.s11n.storeException(2,n),t=s.sq3Codes.SQLITE_IOERR}w("xAccess",t)},xClose:async function(e){d.delete(e);const t=l[e];let n=0;if(t){if(delete l[e],await u(t),t.deleteOnClose)try{await t.dirHandle.removeEntry(t.filenamePart)}catch(a){r("Ignoring dirHandle.removeEntry() failure of",t,a)}}else s.s11n.serialize(),n=s.sq3Codes.SQLITE_NOTFOUND;w("xClose",n)},xDelete:async function(...e){const t=await m.xDeleteNoWait(...e);w("xDelete",t)},xDeleteNoWait:async function(e,t=0,n=!1){let a=0;try{for(;e;){const[s,a]=await y(e,!1);if(!a)break;if(await s.removeEntry(a,{recursive:n}),4660!==t)break;n=!1,(e=f(e,!0)).pop(),e=e.join("/")}}catch(i){s.s11n.storeException(2,i),a=s.sq3Codes.SQLITE_IOERR_DELETE}return a},xFileSize:async function(e){const t=l[e];let n=0;try{const e=await(await h(t,"xFileSize")).getSize();s.s11n.serialize(Number(e))}catch(a){s.s11n.storeException(1,a),n=O.convertRc(a,s.sq3Codes.SQLITE_IOERR)}await g(t),w("xFileSize",n)},xLock:async function(e,t){const n=l[e];let a=0;const i=n.xLock;if(n.xLock=t,!n.syncHandle)try{await h(n,"xLock"),d.delete(e)}catch(o){s.s11n.storeException(1,o),a=O.convertRc(o,s.sq3Codes.SQLITE_IOERR_LOCK),n.xLock=i}w("xLock",a)},xOpen:async function(e,t,n,a){const i="xOpen",o=s.sq3Codes.SQLITE_OPEN_CREATE&n;try{let c,d;try{[c,d]=await y(t,!!o)}catch(r){return s.s11n.storeException(1,r),void w(i,s.sq3Codes.SQLITE_NOTFOUND)}if(s.opfsFlags.OPFS_UNLINK_BEFORE_OPEN&a)try{await c.removeEntry(d)}catch(r){}const f=await c.getFileHandle(d,{create:o}),u=Object.assign(Object.create(null),{fid:e,filenameAbs:t,filenamePart:d,dirHandle:c,fileHandle:f,sabView:s.sabFileBufView,readOnly:!o&&!!(s.sq3Codes.SQLITE_OPEN_READONLY&n),deleteOnClose:!!(s.sq3Codes.SQLITE_OPEN_DELETEONCLOSE&n)});u.releaseImplicitLocks=a&s.opfsFlags.OPFS_UNLOCK_ASAP||s.opfsFlags.defaultUnlockAsap,l[e]=u,w(i,0)}catch(r){c(i,r),s.s11n.storeException(1,r),w(i,s.sq3Codes.SQLITE_IOERR)}},xRead:async function(e,t,n){let a,i=0;const o=l[e];try{a=(await h(o,"xRead")).read(o.sabView.subarray(0,t),{at:Number(n)}),a<t&&(o.sabView.fill(0,a,t),i=s.sq3Codes.SQLITE_IOERR_SHORT_READ)}catch(r){c("xRead() failed",r,o),s.s11n.storeException(1,r),i=O.convertRc(r,s.sq3Codes.SQLITE_IOERR_READ)}await g(o),w("xRead",i)},xSync:async function(e,t){const n=l[e];let a=0;if(!n.readOnly&&n.syncHandle)try{await n.syncHandle.flush()}catch(i){s.s11n.storeException(2,i),a=s.sq3Codes.SQLITE_IOERR_FSYNC}w("xSync",a)},xTruncate:async function(e,t){let n=0;const a=l[e];try{p("xTruncate",a),await(await h(a,"xTruncate")).truncate(t)}catch(i){c("xTruncate():",i,a),s.s11n.storeException(2,i),n=O.convertRc(i,s.sq3Codes.SQLITE_IOERR_TRUNCATE)}await g(a),w("xTruncate",n)},xUnlock:async function(e,t){let n=0;const a=l[e];if(a.syncHandle&&s.sq3Codes.SQLITE_LOCK_NONE===t)try{await u(a)}catch(i){s.s11n.storeException(1,i),n=s.sq3Codes.SQLITE_IOERR_UNLOCK}w("xUnlock",n)},xWrite:async function(e,t,n){let a;const i=l[e];try{p("xWrite",i),a=t===(await h(i,"xWrite")).write(i.sabView.subarray(0,t),{at:Number(n)})?0:s.sq3Codes.SQLITE_IOERR_WRITE}catch(o){c("xWrite():",o,i),s.s11n.storeException(1,o),a=O.convertRc(o,s.sq3Codes.SQLITE_IOERR_WRITE)}await g(i),w("xWrite",a)}},S=async function(){const e=Object.create(null);for(let n of Object.keys(s.opIds)){const t=m[n];if(!t)continue;const a=Object.create(null);e[s.opIds[n]]=a,a.key=n,a.f=t}for(;!I;)try{if("not-equal"!==Atomics.wait(s.sabOPView,s.opIds.whichOp,0,s.asyncIdleWaitTime)){await b();continue}const t=Atomics.load(s.sabOPView,s.opIds.whichOp);Atomics.store(s.sabOPView,s.opIds.whichOp,0);const a=e[t]??n("No waitLoop handler for whichOp #",t),i=s.s11n.deserialize(!0)||[];a.f?await a.f(...i):c("Missing callback for opId",t)}catch(t){c("in waitLoop():",t)}};navigator.storage.getDirectory().then((function(e){s.rootDir=e,globalThis.onmessage=function({data:e}){switch(e.type){case"opfs-async-init":{const a=e.args;for(const e in a)s[e]=a[e];s.verbose=a.verbose??1,s.sabOPView=new Int32Array(s.sabOP),s.sabFileBufView=new Uint8Array(s.sabIO,0,s.fileBufferSize),s.sabS11nView=new Uint8Array(s.sabIO,s.sabS11nOffset,s.sabS11nSize),Object.keys(m).forEach((e=>{Number.isFinite(s.opIds[e])||n("Maintenance required: missing state.opIds[",e,"]")})),(()=>{if(s.s11n)return s.s11n;const e=new TextDecoder,t=new TextEncoder("utf-8"),a=new Uint8Array(s.sabIO,s.sabS11nOffset,s.sabS11nSize),i=new DataView(s.sabIO,s.sabS11nOffset,s.sabS11nSize);s.s11n=Object.create(null);const o=Object.create(null);o.number={id:1,size:8,getter:"getFloat64",setter:"setFloat64"},o.bigint={id:2,size:8,getter:"getBigInt64",setter:"setBigInt64"},o.boolean={id:3,size:4,getter:"getInt32",setter:"setInt32"},o.string={id:4};const r=e=>{switch(e){case o.number.id:return o.number;case o.bigint.id:return o.bigint;case o.boolean.id:return o.boolean;case o.string.id:return o.string;default:n("Invalid type ID:",e)}};s.s11n.deserialize=function(t=!1){const n=a[0],o=n?[]:null;if(n){const t=[];let c,l,d,f=1;for(c=0;c<n;++c,++f)t.push(r(a[f]));for(c=0;c<n;++c){const n=t[c];n.getter?(d=i[n.getter](f,s.littleEndian),f+=n.size):(l=i.getInt32(f,s.littleEndian),f+=4,d=e.decode(a.slice(f,f+l)),f+=l),o.push(d)}}return t&&(a[0]=0),o},s.s11n.serialize=function(...e){if(e.length){const c=[];let l=0,d=1;for(a[0]=255&e.length;l<e.length;++l,++d)c.push((r=e[l],o[typeof r]||n("Maintenance required: this value type cannot be serialized.",r))),a[d]=c[l].id;for(l=0;l<e.length;++l){const n=c[l];if(n.setter)i[n.setter](d,e[l],s.littleEndian),d+=n.size;else{const n=t.encode(e[l]);i.setInt32(d,n.byteLength,s.littleEndian),d+=4,a.set(n,d),d+=n.byteLength}}}else a[0]=0;var r},s.s11n.storeException=s.asyncS11nExceptions?(e,t)=>{e<=s.asyncS11nExceptions&&s.s11n.serialize([t.name,": ",t.message].join(""))}:()=>{},s.s11n})(),o("init state",s),t("opfs-async-inited"),S();break}case"opfs-async-restart":I&&(r("Restarting after opfs-async-shutdown. Might or might not work."),I=!1,S())}},t("opfs-async-loaded")})).catch((e=>c("error initializing OPFS asyncer:",e)))};globalThis.SharedArrayBuffer?globalThis.Atomics?globalThis.FileSystemHandle&&globalThis.FileSystemDirectoryHandle&&globalThis.FileSystemFileHandle&&globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle&&(null==(e=null==navigator?void 0:navigator.storage)?void 0:e.getDirectory)?n():t("opfs-unavailable","Missing required OPFS APIs."):t("opfs-unavailable","Missing Atomics API.","The server must emit the COOP/COEP response headers to enable that."):t("opfs-unavailable","Missing SharedArrayBuffer API.","The server must emit the COOP/COEP response headers to enable that.")}();
